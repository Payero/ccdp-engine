/**
 * 
 */
package com.axios.ccdp.mesos.fmwk;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.StringJoiner;

import org.apache.log4j.Logger;
import org.apache.mesos.Protos.CommandInfo;
import org.apache.mesos.Protos.ExecutorID;
import org.apache.mesos.Protos.ExecutorInfo;
import org.apache.mesos.Protos.FrameworkID;
import org.apache.mesos.Protos.MasterInfo;
import org.apache.mesos.Protos.Offer;
import org.apache.mesos.Protos.OfferID;
import org.apache.mesos.Protos.Resource;
import org.apache.mesos.Protos.SlaveID;
import org.apache.mesos.Protos.TaskID;
import org.apache.mesos.Protos.TaskInfo;
import org.apache.mesos.Protos.TaskState;
import org.apache.mesos.Protos.TaskStatus;
import org.apache.mesos.Protos.Value;
import org.apache.mesos.Protos;
import org.apache.mesos.Scheduler;
import org.apache.mesos.SchedulerDriver;
import org.apache.mesos.Protos.Filters;
import org.apache.mesos.Protos.Attribute;

import com.axios.ccdp.fmwk.CcdpEngine;
import com.axios.ccdp.resources.CcdpVMResource;
import com.axios.ccdp.resources.CcdpVMResource.ResourceStatus;
import com.axios.ccdp.tasking.CcdpTaskRequest;
import com.axios.ccdp.tasking.CcdpThreadRequest;
import com.axios.ccdp.tasking.CcdpTaskRequest.CcdpTaskState;
import com.axios.ccdp.utils.CcdpUtils;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.google.protobuf.ByteString;

/**
 * Class used to coordinate the tasking among multiple Virtual Machines.  It 
 * uses the information on the task to make determinations regarding where to 
 * execute the task.  Information affecting the task execution includes, but 
 * not limited, the following fields:
 * 
 *  - NodeType: Based on the node type, it can run on a simple EC2 instance or
 *              a cluster such as EMR, Hadoop, etc.
 *  - CPU:  The CPU value determines the schema to use as follow:
 *      CPU = 0:        Let the Scheduler decide where to run it
 *      0 &gt; CPU &lt; 100:  Use the first VM with enough resources to run the task
 *      CPU = 100:      Run this task by itself on a new VM
 *  
 * @author Oscar E. Ganteaume
 *
 */
public class CcdpMesosScheduler implements Scheduler
{
  /**
   * Stores the Framework Unique ID this Scheduler is running under
   */
  private FrameworkID fmwkId;
  /**
   * Stores the Executor responsible for running the tasks
   */
  private ExecutorInfo executor;
  /**
   * Stores the scheduler driver requesting the command execution
   */
  private SchedulerDriver driver = null;
  /**
   * Generates debug print statements based on the verbosity level.
   */
  private Logger logger = 
      Logger.getLogger(CcdpMesosScheduler.class.getName());
  /**
   * Creates all the JSON objects
   */
  private ObjectMapper mapper = new ObjectMapper();
  /**
   * The object responsible for the task assignment and resource management
   */
  private CcdpEngine engine = null;
  
  /**
   * Instantiates a new executors and starts the jobs assigned as the jobs
   * argument.  If the jobs is null then it ignores them
   * 
   * @param execInfo the name of the executor to use to execute the tasks
   * @param jobs an optional list of jobs
   */
  public CcdpMesosScheduler( ExecutorInfo execInfo, List<CcdpThreadRequest> jobs)
  {
    this.logger.debug("Creating a new CCDP Remote Scheduler");
    this.executor = execInfo;
    this.engine = new CcdpEngine(jobs);
  }


  /**
   * Invoked when the scheduler successfully registers with a Mesos master. 
   * A unique ID (generated by the master) used for distinguishing this 
   * framework from others and MasterInfo with the IP and port of the current 
   * master are provided as arguments.
   * 
   * @param driver - The scheduler driver that was registered.
   * @param fmwkId - The framework ID generated by the master.
   * @param master - Info about the current master, including IP and port.
   * 
   */
  @Override
  public void registered(SchedulerDriver driver, FrameworkID fmwkId, 
                         MasterInfo master)
  {
    this.logger.info("registered: FwkId " + 
                    fmwkId.getValue() + " MasterInfo " + master.toString() );
    
    this.fmwkId = fmwkId;
    this.driver = driver;
  }

  /**
   * Invoked when the scheduler re-registers with a newly elected Mesos master. 
   * This is only called when the scheduler has previously been registered. 
   * MasterInfo containing the updated information about the elected master is 
   * provided as an argument.
   * 
   * @param driver - The driver that was re-registered.
   * @param master - The updated information about the elected master.
   * 
   */
  @Override
  public void reregistered(SchedulerDriver driver, MasterInfo master)
  {
    this.logger.info("reregistered: "+ driver.toString() + 
                     " MasterInfo " + master.toString() );
    this.driver = driver;
  }
  
  /**
   * Invoked when resources have been offered to this framework. A single offer 
   * will only contain resources from a single slave. Resources associated with 
   * an offer will not be re-offered to _this_ framework until either (a) this 
   * framework has rejected those resources (see 
   * SchedulerDriver.launchTasks(Collection&lt;OfferID&gt;, Collection&lt;TaskInfo&gt;, 
   *                             Filters)) 
   * or (b) those resources have been rescinded (see 
   * offerRescinded(SchedulerDriver, OfferID)). Note that resources may be 
   * concurrently offered to more than one framework at a time (depending on 
   * the allocator being used). In that case, the first framework to launch 
   * tasks using those resources will be able to use them while the other 
   * frameworks will have those resources rescinded (or if a framework has 
   * already launched tasks with those resources then those tasks will fail 
   * with a TASK_LOST status and a message saying as much).
   * 
   * @param driver - The driver that was used to run this scheduler.
   * @param offers - The resources offered to this framework.
   * 
   */
  @Override
  public void resourceOffers(SchedulerDriver driver, List<Offer> offers)
  {

    this.logger.info("resourceOffers: Got some resource Offers" );
    
    // generates a list of resources using the offers
    for( Offer offer : offers )
    {
      this.logger.warn("The Offer " + offer.toString() );
      StringBuffer buf = new StringBuffer();
      buf.append("----------------- Offer -----------------\n");
      
      buf.append("Agent ID: ");
      buf.append(offer.getSlaveId().getValue());
      buf.append("\n");
      
      buf.append("\tHost: ");
      buf.append(offer.getHostname());
      buf.append("\n");
      
      
      String id = null;
      String sid = null;
      String aid = offer.getSlaveId().getValue();
      
      // Getting the attribute information
      for( Attribute attr : offer.getAttributesList() )
      {
        switch( attr.getName() )
        {
        case CcdpUtils.KEY_INSTANCE_ID:
          id = attr.getText().getValue();
          buf.append("\tInstance Id: ");
          buf.append(id);
          buf.append("\n");
          break;
        case CcdpUtils.KEY_SESSION_ID:
          sid = attr.getText().getValue();
          buf.append("\tSession ID: ");
          buf.append(sid);
          buf.append("\n");
          break;
        }
      }
      
      
      // if the instance id was not set use the agent id
      if( id == null )
        id = aid;

      // creating a CcdpVMResource object to compare
      CcdpVMResource vm = new CcdpVMResource(id);
      this.logger.debug("Resource " + id + " was not found creating it");
      vm.setStatus(ResourceStatus.RUNNING);
      
      vm.setAssignedSession(sid);
      vm.setHostname(offer.getHostname());

      buf.append("\tAssigned Session ID: ");
      buf.append(vm.getAssignedSession());
      buf.append("\n");

      buf.append("-----------------------------------------\n");
      this.logger.debug("\n" + buf.toString() );

      this.logger.debug("Offer InstanceID[" + id + "]");
      vm.setAgentId(aid);
      
      // We always need to extract the resource info from the offer
      for( Resource r : offer.getResourcesList() )
      {
        switch( r.getName() )
        {
          case "cpus":
            vm.setCPU( r.getScalar().getValue() );
            break;
          case "mem":
            vm.setMEM( r.getScalar().getValue() );
            break;
          case "disk":
            vm.setDisk( r.getScalar().getValue() );
            break;
        }
        
      }// end of resources loop
      
      List<CcdpTaskRequest> tasks = this.engine.allocateTasks(vm);
      this.logger.debug("Found " + tasks.size() + " Task to allocate");
      List<TaskInfo> taskInfo = this.makeTasks(tasks, vm.getAgentId());
      
      List<Offer.Operation> ops = new ArrayList<>();
      for( TaskInfo ti : taskInfo)
      {
        Offer.Operation.Launch.Builder launch = 
            Offer.Operation.Launch.newBuilder();
        launch.addTaskInfos(TaskInfo.newBuilder(ti));
        
        Offer.Operation operation = Offer.Operation.newBuilder()
            .setType(Offer.Operation.Type.LAUNCH)
            .setLaunch(launch)
            .build();
  
          ops.add(operation);
      }
      
      List<OfferID> list = Collections.singletonList( offer.getId() );
      Filters filters = Filters.newBuilder().setRefuseSeconds(5).build();
      this.driver.acceptOffers(list, ops, filters);
      
    }// end of the offers loop
  }


  /**
   * Invoked when the status of a task has changed (e.g., a slave is lost and 
   * so the task is lost, a task finishes and an executor sends a status update 
   * saying so, etc). If implicit acknowledgements are being used, then 
   * returning from this callback _acknowledges_ receipt of this status update! 
   * If for whatever reason the scheduler aborts during this callback (or the 
   * process exits) another status update will be delivered (note, however, 
   * that this is currently not true if the slave sending the status update is 
   * lost/fails during that time). If explicit acknowledgements are in use, the 
   * scheduler must acknowledge this status on the driver.
   * 
   * @param driver - The driver that was used to run this scheduler.
   * @param status - The status update, which includes the task ID and status.
   * 
   */
  public void statusUpdate(SchedulerDriver driver, TaskStatus status)
  {
    String taskId = status.getTaskId().getValue();
    this.logger.info("statusUpdate TaskStatus: " + taskId );
    this.logger.info("Status: " + status.getState());
    
    CcdpTaskState state = null;
    
    switch ( status.getState() )
    {
      case TASK_STARTING:
      case TASK_RUNNING:
        state = CcdpTaskState.RUNNING;
        break;
      case TASK_FINISHED:
        state = CcdpTaskState.SUCCESSFUL;
        break;
      case TASK_FAILED:
      case TASK_KILLED:
      case TASK_LOST:
      case TASK_ERROR:
        state = CcdpTaskState.FAILED;
        break;
      default:
        break;
    }// end of switch statement

    this.engine.taskUpdate(taskId, state);
  }
  
  /***************************************************************************/
  /***************************************************************************/
  /***************************************************************************/
  
  /**
   * Makes sure that what the Master Mesos believes is the state of the cluster
   * matches to the Scheduler's view.  Messages between framework schedulers 
   * and the Mesos master may be dropped due to failures and network partitions. 
   * This may cause a framework scheduler and the master to have different views 
   * of the current state of the cluster
   */
  public void reconcileTasks()
  {
    this.logger.debug("Reconciling Tasks");
    List<TaskStatus> runningTasks = new ArrayList<>();
    List<CcdpTaskRequest> tasks = 
        this.engine.getTasksByState( CcdpTaskState.RUNNING );
    
    for( CcdpTaskRequest task : tasks )
    {
      TaskID id = TaskID.newBuilder()
          .setValue( task.getTaskId() )
          .build();
      SlaveID slaveId = SlaveID.newBuilder()
         .setValue( task.getHostId() )
         .build();
      
      this.logger.debug("Reconciling Task: " + task.getTaskId() );
      TaskStatus.Builder bldr = TaskStatus.newBuilder();
      bldr.setSlaveId(slaveId);
      bldr.setTaskId(id);
      bldr.setState(TaskState.TASK_RUNNING);
      runningTasks.add( bldr.build() );
    }
    
    this.driver.reconcileTasks(runningTasks);
  }
  
  /**
   * Generates all the TaskInfo objects required to run the assigned tasks in
   * the given mesos agent.
   * 
   * @param tasks all the tasks to launch 
   * @param targetSlave the agent id of the mesos node assigned to run all 
   *        these tasks
   *        
   * @return a list of TaskInfo object that are used to launch the given tasks
   */
  private List<TaskInfo> makeTasks(List<CcdpTaskRequest> tasks, String agent )
  {
    List<TaskInfo> list = new ArrayList<>();
    for( CcdpTaskRequest task : tasks )
    {
      list.add(this.makeTask(agent, task));
    }
    
    return list;
  }
  
  /**
   * Generates a TaskInfo object that will be executed by the appropriate Mesos 
   * Agent.
   * 
   * @param targetSlave the Unique identifier of the Mesos Agent responsible for
   *        running this task
   * @param exec The mesos executor to use to execute the task
   * 
   * @return a TaskInfo object containing all the information required to run
   *         this job
   */
  private TaskInfo makeTask(String targetSlave, CcdpTaskRequest task)
  {
    this.logger.info("Making Task at Slave " + targetSlave);
    TaskID id = TaskID.newBuilder().setValue(task.getTaskId()).build();
    
    Protos.TaskInfo.Builder bldr = TaskInfo.newBuilder();
    bldr.setName("task " + id.getValue());
    bldr.setTaskId(id);
    // Adding the CPU
    Protos.Resource.Builder resBldr = Resource.newBuilder();
    resBldr.setName("cpus");
    resBldr.setType(Value.Type.SCALAR);
    resBldr.setScalar(Value.Scalar.newBuilder().setValue(task.getCPU()));
    Resource cpuRes = resBldr.build();
    bldr.addResources(cpuRes);
    
    // Adding the Memory
    resBldr.setName("mem");
    resBldr.setType(Value.Type.SCALAR);
    resBldr.setScalar(Value.Scalar.newBuilder().setValue(task.getMEM()));
    Resource memRes = resBldr.build();
    bldr.addResources(memRes);
    
    Protos.CommandInfo.Builder cmdBldr = CommandInfo.newBuilder();
    StringJoiner joiner = new StringJoiner(" ");
    task.getCommand().forEach(joiner::add);
    
    String cmd = joiner.toString();
    cmdBldr.setValue(cmd);
    this.logger.debug("Running Command: " + cmd);
    
    Protos.SlaveID.Builder slvBldr = SlaveID.newBuilder();
    slvBldr.setValue(targetSlave);
    bldr.setSlaveId(slvBldr.build());
    
    bldr.setExecutor( ExecutorInfo.newBuilder(this.executor) );
    ObjectNode json = this.mapper.createObjectNode();
    
    task.getCommand();
    task.getConfiguration();
    Map<String, String> cfg = task.getConfiguration();
    // if there is a configuration, add it
    if( cfg != null )
    {
      JsonNode jsonNode = mapper.convertValue(cfg, JsonNode.class);
      json.set("cfg", jsonNode);
    }
    
    json.put("cmd", cmd);
    
    bldr.setData(ByteString.copyFrom(json.toString().getBytes()));
    return bldr.build();
  }
  
  /**
   * Invoked when the scheduler becomes "disconnected" from the master (e.g., 
   * the master fails and another is taking over). 
   * 
   * @param driver - The driver that was used to run this scheduler.
   */
   @Override
   public void disconnected(SchedulerDriver driver)
   {
     this.logger.info("disconnected: " + driver.toString() );
   }

   /**
    * Invoked when there is an unrecoverable error in the scheduler or driver. 
    * The driver will be aborted BEFORE invoking this callback.  
    * 
    * @param driver - The driver that was used to run this scheduler.
    * @param error - The error message.
    */
   @Override
   public void error(SchedulerDriver driver, String error)
   {
     this.logger.error("error: " + error + " Driver: " + driver.toString() );
   }

   /**
    * Invoked when an executor has exited/terminated. Note that any tasks running 
    * will have TASK_LOST status updates automagically generated.   
    * 
    * NOTE: This callback is not reliably delivered. If a host or network failure 
    * causes messages between the master and the scheduler to be dropped, this 
    * callback may not be invoked.
    * 
    * @param driver - The driver that was used to run this scheduler.
    * @param execId - The ID of the executor that was lost.
    * @param slvId - The ID of the slave that launched the executor.
    * @param status - The exit status of the executor.
    * 
    */
   @Override
   public void executorLost(SchedulerDriver driver, ExecutorID execId, SlaveID slvId,
       int status)
   {
     this.logger.error("executorLost: " + " Driver: " + driver.toString() + 
                 " ExecId " + execId + " SlaveId: " + slvId + " Int? " + status) ;
     this.engine.resourceLost( slvId.getValue() );
   }

   /**
    * Invoked when an executor sends a message. These messages are best effort; 
    * do not expect a framework message to be retransmitted in any reliable 
    * fashion.
    * 
    * @param driver - The driver that received the message.
    * @param execId - The ID of the executor that sent the message.
    * @param slvId - The ID of the slave that launched the executor.
    * @param data - The message payload.
    * 
    */
   @Override
   public void frameworkMessage(SchedulerDriver driver, ExecutorID execId,
       SlaveID slvId, byte[] data)
   {
     this.logger.debug("frameworkMessage: " + new String(data) + " Driver: " + 
             driver.toString() + " ExecId " + execId + " SlaveId: " + slvId);
     ObjectNode node = this.mapper.createObjectNode();
     node.put("type", "message");
     node.put("data", new String(data));
     this.engine.onMessage(node);
   }

   /**
    * Invoked when an offer is no longer valid (e.g., the slave was lost or 
    * another framework used resources in the offer). If for whatever reason an 
    * offer is never rescinded (e.g., dropped message, failing over framework, 
    * etc.), a framework that attempts to launch tasks using an invalid offer 
    * will receive TASK_LOST status updates for those tasks (see 
    * resourceOffers(SchedulerDriver, List&lt;Offer&gt;)).
    * 
    * @param driver - The driver that was used to run this scheduler.
    * @param offerId - The ID of the offer that was rescinded.
    * 
    */
   @Override
   public void offerRescinded(SchedulerDriver driver, OfferID offerId)
   {
     this.logger.info("offerRescinded " + driver.toString() + 
                      " OfferId " + offerId.toString() );
   }
   
   /**
    * Invoked when a slave has been determined unreachable (e.g., machine 
    * failure, network partition). Most frameworks will need to reschedule any 
    * tasks launched on this slave on a new slave. NOTE: This callback is not 
    * reliably delivered. If a host or network failure causes messages between 
    * the master and the scheduler to be dropped, this callback may not be 
    * invoked.
    * 
    * @param driver - The driver that was used to run this scheduler.
    * @param slvId - The ID of the slave that was lost.
    * 
    */
   @Override
   public void slaveLost(SchedulerDriver driver, SlaveID slvId)
   {
     this.logger.info("slaveLost " + driver.toString() + 
                      " SlaveId: " + slvId.toString() );
   }
}
